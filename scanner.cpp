#include <iostream>
#include <string>
#include <vector>
#include <tuple>
#include <windows.h>
#include <tchar.h>
#include "typedef.h"
#include "PEparser.h"
#include "scanner.h"

using namespace scanner;
using std::hex;

void scannerMain() {
	HANDLE PEFileMapping = NULL;
	tstring filePath = _T("C:\\Windows\\System32\\shell32.dll");

	PEFileMapping = peclass.getPEFileMapping(filePath);
}

void scanner::Scanner::debug(tstring debugmsg) {
	OutputDebugStringT(debugmsg.c_str());
	OutputDebugStringT(_T("\n"));
}

//PE ???? ??¥è? ??©ö?? .text ?????? ??? ??? ????? ???
DWORD scanner::getTextSectionSize(const tstring filePath) {
	PEParse::PEParser peclass = PEParse::PEParser();
	HANDLE peFileMapping = NULL;
	LPVOID peBaseAddress = NULL;
	IMAGE_DOS_HEADER* peDosHeader = NULL;

	peFileMapping = peclass.getPEFileMapping(filePath);
	peBaseAddress = peclass.getPEBaseAddress(peFileMapping);
	peDosHeader = (IMAGE_DOS_HEADER*)peBaseAddress;

	IMAGE_NT_HEADERS32* ntHeader = (IMAGE_NT_HEADERS32*)((BYTE*)peBaseAddress + (WORD)peDosHeader->e_lfanew);
    IMAGE_SECTION_HEADER* sectionHeader = (IMAGE_SECTION_HEADER*)((BYTE*)(&ntHeader->OptionalHeader) + (ntHeader->FileHeader.SizeOfOptionalHeader));

    if (sectionHeader == NULL) 
        debug(_T("Error: Invalid Image Section Header\n"));
	else {
		for (int i = 0; i < (WORD)ntHeader->FileHeader.NumberOfSections; i++) {
			if ((char*)sectionHeader[i].Name == ".text") 
				// VirtualSize : ???? ???? ???. (NULL ?¬Ö? ????? ??.)
				return (DWORD)sectionHeader[i].Misc.VirtualSize;
		}
	}
	return NULL;
}

// ????????? ??©ö??? ?????? ???? ??????, ???? ???? PE ?????? .text ???? ??????? ????? ??????? ???
BYTE* scanner::getTextSectionBytes(const tstring filePath, DWORD sectionSize) {
	PEParse::PEParser peclass = PEParse::PEParser(); 
	HANDLE peFileMapping = NULL;
	LPVOID peBaseAddress = NULL;
	IMAGE_DOS_HEADER* peDosHeader = NULL;

	peFileMapping = peclass.getPEFileMapping(filePath);
	peBaseAddress = peclass.getPEBaseAddress(peFileMapping);
	peDosHeader = (IMAGE_DOS_HEADER*)peBaseAddress;

	IMAGE_NT_HEADERS32* ntHeader = (IMAGE_NT_HEADERS32*)((BYTE*)peBaseAddress + (WORD)peDosHeader->e_lfanew);
	IMAGE_SECTION_HEADER* sectionHeader = (IMAGE_SECTION_HEADER*)((BYTE*)(&ntHeader->OptionalHeader) + (ntHeader->FileHeader.SizeOfOptionalHeader));

	if (sectionHeader == NULL) 
		debug(_T("Error: Invalid Image Section Header\n"));
	else {
		for (int i = 0; i < (WORD)ntHeader->FileHeader.NumberOfSections; i++) {
			if ((char*)sectionHeader[i].Name == ".text") {
				BYTE* sectionBytes = new BYTE[sectionSize];
				memcpy(sectionBytes, (BYTE*)peBaseAddress + sectionHeader[i].VirtualAddress, sectionSize);
				return sectionBytes;
			}
		}
	}
	return NULL;
}

// getTextSectionBytes ??????? ????? ???? ??????? ???
void Scanner::freeTextSectionBytes(BYTE* sectionBytes)
{
	delete[] sectionBytes;
}

// getTextSectionBytes ??????? ????? ???? ???? ?????? ?????? ?????? ???
BOOL Scanner::scanMalwarePattern(BYTE* sectionBytes, DWORD sectionSize) {
	// ?????? ?????? ?????? ?ò÷
	BYTE malwarePattern[8] = { 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x53, 0x56 };
	// ?????? ?????? ???
	DWORD malwarePatternSize = sizeof(malwarePattern) / sizeof(BYTE);

	// ?????? ?????? ????? ????? ??? ?????? ?????? ????? ?????? ????? ??? ??????? FALSE ???
	if (sectionSize < malwarePatternSize) 
		return FALSE;

	// ?????? ?????? ????? ????? ??? ?????? ?????? ????? ???? ?????? ??? ????
	for (int i = 0; i < sectionSize - malwarePatternSize; i++) {
		// ?????? ?????? ???? ???? ?????? ?????? ????? ???????? ???
		if (memcmp(sectionBytes + i, malwarePattern, malwarePatternSize) == 0) {
			// ?????? ????? ?????? TRUE ???
			return TRUE;
		}
	}
	// ?????? ????? ?????? ???? ??? ????? FALSE ???
	return FALSE;
}

// getTextSectionBytes ??????? ?¬à?? ????? ?? ????? ?????? ?????? ???
void Scanner::debugTextSectionBytes(BYTE* sectionBytes, DWORD sectionSize) {
	for (int i = 0; i < sectionSize; i++) {
		tcout << hex << (int)sectionBytes[i] << _T(" ");
		if (i % 16 == 15) 
			tcout << endl;
	}
}

//EntryPointSection ?????? ?????? ??? ?????? ??? ????? ?????? ??? ???
DWORD Scanner::getEntryPointSection(const tstring filePath) {
	PEParse::PEParser peclass = PEParse::PEParser();
	HANDLE peFileMapping = NULL;
	peFileMapping = peclass.getPEFileMapping(filePath);
}

//PE ???? ??¥è? ??©ö?? DEBUG_FILE_DIRECTORY?? ???? pdb ??¥è? ????? ???
tstring Scanner::getPdbPath(const tstring filePath) {
	PEParse::PEParser peclass = PEParse::PEParser();
	HANDLE peFileMapping = NULL;
	peFileMapping = peclass.getPEFileMapping(filePath);
}